#
# An example configuration for a django application that uses a postgres
# database.  Django stores database tables and fixtures as python code.
# The `database` task is used to build a minimal image that includes the
# tables and fixtures data, without any of the python code or dependencies.
#

#
# An `image` resource
#
# Produces a docker image with one or more tags.
#
image=app:
  image: "django-app-name"
  context: .
  tags: ["${UNIQUE_ID}", "${GIT.SHA}", "dev"]

#
# An `image` resource
#
# Produces a docker image with one or more tags.
# This resource depends on a container task.
#
image=database:
  image: "app-name-database"
  context: dockerfiles/database
  tags: ["${UNIQUE_ID}", "${GIT.SHA}", "dev"]
  args:
    VERSION: 1.2
  depends: ['database-export']

#
# A `container` resource
#
# Runs a docker container from an existing image.
#
run=database-empty:
  container: "database-empty-${UNIQUE_ID}"
  image: "postgres:9.4"

#
# A `volume` resource
#
# Manages a named volume
#
volume=database-sql:
  volume: "app-name-sql"
  type: "host"
  path: "./target"

#
# A `container` resource
#
# Runs a docker container with an image from an image resource and a custom
# command.
#
run=database-export:
  container: "database-export-${UNIQUE_ID}"
  image:
    resource: "app"
  command: "export-db.sh --host database-empty-${UNIQUE_ID} /target/export.sql"
  artifact: "./target/export.sql"
  depends:
    - resource: "database-empty"
      state: "running"
    - resource: "database-sql"
      path: "/target"
